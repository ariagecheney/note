# 作用域：变量的生命周期 或者 变量的时空访问控制
* 概念  
在java编程中，将变量声明在不同的位置就具有不同的作用域，而作用域的大小则使用{……}来确定，使用{……}可以确定定义的变量的可见性及生命周期。
* 分类
    * 全局作用域
    * 函数作用域（作用域嵌套，例如js）
    * 块级作用域（java）

* 原理或者说实现   
编译

### [js作用域](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
* 函数级作用域（区别于块级作用域）  
内部的变量，内部都能访问，外部不能访问内部的变量，内部能访问外部的变量，若有相同的变量，采用按执行顺序，就近原则   
**js调用/访问前置,按顺序执行，但是先收集所有定义**  
* 闭包 (返回函数)  
* 理解1


1、一个含有自由变量的函数；   
2、这些自由变量所在的环境。   
外部环境持有内部函数所使用的自由变量，对内部函数形成“闭包”，就这样。 
简单但不严格的说，一个函数的“自由变量”就是既不是参数也不是局部变量的变量。 

一个纯粹（无副作用)的函数如果不含有自由变量，那么每次用相同的参数调用后的得到的结果肯定是一样的。但如果一个函数含有自由变量，那么调用返回的结果不但依赖于参数的值，还依赖于自由变量的值。因此一个含有自由变量的函数要正确执行，必须保证其所依赖的外围环境的存在。 

基于类的面向对象程序语言中有一种情况，就是方法是用的自由变量是来自其所在的类的实例的。像这样：

```java
class Foo {  
    private int x;  
    int AddWith( int y ) { 
        return x + y;
    }  
}  
```

这样的AddWith()有一个参数y和一个自由变量x，其返回的值既依赖于参数的值也依赖于自由变量的值。为了让AddWith()正确工作，它必须依附于Foo的一个实例，不然就得不到x的值了（称为：“变量i未与值相绑定”）。很好理解对吧。不过面向对象的语言里一般不把类称为闭包，没为什么，就是种习惯。 
当然严格来说方法所捕获的自由变量不是x，而是this；x是通过this来访问到的，完整写出应该是this.x。 

如果这个“外围环境”来自一个外围函数，并且内部函数可以作为返回值返回，那么外围函数的局部环境就不能在调用结束时就撤销。也就是说不能在栈上分配空间。 
```js
function AddWith(x) {  
    return function(y) {  
        return x + y  
    }  
}  
```
这样的内部函数有一个参数y和一个自由变量x。x在外围函数AddWith()里是一个参数，也就是一个“已绑定了值的变量”（bound variable）。AddWith()的局部作用域中含有内部函数所使用的自由变量，对内部函数形成闭包。为了让返回出去的内部函数能正常工作，这个内部函数必须依附于一个能提供x的值的环境，也就是AddWith()提供的闭包。这样我们就能够： 
```js
var addFive = AddWith(5)  
var seven = addFive(2) // 2+5=7  
```

全局变量是一种特殊的自由变量。

* 理解2  
使能访问到内部的变量（返回的函数返回了内部的变量） 容易造成内存泄露　　

* this 使用  指当前对象（环境） 的调用者(owner)  闭包时则一般指向window  
由于 javascript的动态性（解释执行，当然也有简单的预编译过程），this的指向在运行时才确定。这个特性在给我们带来迷惑的同时也带来了编程上的 自由和灵活，结合apply(call)方法，可以使JS变得异常强大。

### java 匿名内部类，闭包，lambda 表达式
简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。

故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。
* [参考](https://zhuanlan.zhihu.com/p/29245059)

* 参考  
https://www.jianshu.com/p/8c0bbd072126
http://blog.csdn.net/qq_29924041/article/details/53869798
https://www.jianshu.com/p/efe38b392f53

openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer server.crt -inkey server.key -certfile cert-chain.crt -outform der -nodetach

## Copy-On-Write（读写分离的思想，读和写不同的容器。用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景）
Copy On Write(写时复制) 便是资源管理方面的一种优化技术，广泛的应用于软件开发(如 Java 的 Copy On Write 容器)、虚拟内存管理(如进程的 fork、qemu-kvm 虚拟机镜像乃至 Docker 的 AUFS 文件系统等等。
* fork 之后的父进程和子进程完全共享数据段、代码段、堆和栈等的完全副本，而且内核将共享的地址空间的访问权限改变为只读，如果父进程和紫金陈中的任何一个仕途修改这些区域，则内核职位修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”
* 节省空间、提升效率和更好的支持快照。