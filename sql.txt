sql 对大小写不敏感
日期
基于集合理论
 order by排序 返回游标不能做表达式 select atime, deathnumber, province from full_accident_tbl where (deathnumber>=5 and deathnumber<=10) and province='山东' order by 2

不同值统计 select count(distinct deathnumber) from full_accident_tbl where (deathnumber>=5 and deathnumber<=10) and province='山东';

分组统计 select province, sum(deathnumber) from full_accident_tbl where (deathnumber>=5 and deathnumber<=10) group by province;
+----------+------------------+
| province | sum(deathnumber) |
+----------+------------------+
| 上海     | 151              |
| 云南     | 1828             |
| 内蒙     | 695              |
| 北京     | 165              |
| 吉林     | 315              |
| 四川     | 1565             |
| 天津     | 84               |
| 宁夏     | 163              |
| 安徽     | 881              |
| 山东     | 1342             |
| 山西     | 1251             |
| 广东     | 1435             |
| 广西     | 966              |
| 新疆     | 818              |
| 江苏     | 569              |
| 江西     | 599              |
| 河北     | 723              |
| 河南     | 895              |
| 浙江     | 1289             |
| 海南     | 151              |
| 湖北     | 754              |
| 湖南     | 1601             |
| 甘肃     | 825              |
| 福建     | 937              |
| 西藏     | 435              |
| 贵州     | 2469             |
| 辽宁     | 772              |
| 重庆     | 915              |
| 陕西     | 957              |
| 青海     | 210              |
| 黑龙江   | 984              |
+----------+------------------+
31 rows in set
当我们选不只一个栏位，且其中至少一个栏位有包含函数的运用时，我们就需要用到 GROUP BY 这个指令。在这个情况下，我们需要确定我们有 GROUP BY 所有其他的栏位。换句话说，除了有包括函数的栏位外，我们都需要将其放在 GROUP BY 的子句中。
或者
select t1.pwd ,count(t1.pwd) from newuser t1 group by t1.pwd;

+----------+---------------+
| pwd      | count(t1.pwd) |
+----------+---------------+
| 123      |             2 |
| 123123   |             1 |
| 123456   |            15 |
| 123465   |             1 |
| 654321   |             1 |
| yr910118 |             1 |
+----------+---------------+

对函数的结果进行筛选不一定需要group子句    select province, sum(deathnumber) from full_accident_tbl where (deathnumber>=5 and deathnumber<=10) group by province having sum(deathnumber) <200
;
+----------+------------------+
| province | sum(deathnumber) |
+----------+------------------+
| 上海     | 151              |
| 北京     | 165              |
| 天津     | 84               |
| 宁夏     | 163              |
| 海南     | 151              |
+----------+------------------+
5 rows in set
或者

select t1.pwd ,count(t1.pwd) from newuser t1 group by t1.pwd having count(pwd) <= 2;
| pwd      | count(t1.pwd) |
+----------+---------------+
| 123      |             2 |
| 123123   |             1 |
| 123465   |             1 |
| 654321   |             1 |
| yr910118 |             1 |
+----------+---------------+
列别名 有空格时用‘’ 及表格别名。

当我们在 WHERE 子句或 HAVING 子句中插入另一个 SQL 语句时，我们就有一个 subquery 的架构。第一，它可以被用来连接表格。另外，有的时候 subquery 是唯一能够连接两个表格的方式。

SELECT SUM(Sales) FROM Store_Information WHERE Store_name IN (SELECT store_name FROM Geography 
WHERE region_name = 'West');


UNION 指令的目的是将两个 SQL 语句的结果合并起来。从这个角度来看， UNION 跟 JOIN 有些许类似，因为这两个指令都可以由多个表格中撷取资料。 UNION 的一个限制是两个 SQL 语句所产生的列需要是同样的资料种类和个数。另外，当我们用 UNION 这个指令时，我们只会看到不同的资料值 (类似 SELECT DISTINCT)。

UNION ALL 这个指令的目的也是要将两个 SQL 语句的结果合并在一起。 UNION ALL 和 UNION 不同之处在于 UNION ALL 会将每一笔符合条件的资料都列出来，无论资料值有无重复。

和 UNION 指令类似，INTERSECT 也是对两个 SQL 语句所产生的结果做处理的。不同的地方是， UNION 基本上是一个 OR (如果这个值存在于第一句或是第二句，它就会被选出)，而 INTERSECT 则比较像 AND ( 这个值要存在于第一句和第二句才会被选出)。UNION 是联集，而 INTERSECT 是交集。
请注意，在 INTERSECT 指令下，不同的值只会被列出一次。

ifconfig eth0 192.168.254.200 netmask 255.255.255.0

网卡配置文件

mysql 命令下执行脚本

第一种方式：在未连接数据库的情况下，输入 mysql -h localhost -u root -p 123456  < d:\book.sql 回车即可；

第二种方式：在已连接数据库的情况下，此时命令提示符为mysql>，输入 source d:\book.sql  或者 \. d:\book.sql 回车即可。