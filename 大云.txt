docker
Docker背后的想法是创建软件程序可移植的轻量容器,Docker背后的想法是创建软件程序可移植的轻量容器.

镜像：镜像拥有唯一ID，以及一个供人阅读的名字和标签对。镜像可以命名为类似ubuntu:latest、ubuntu:precise、django:1.6、django:1.7等等。
容器：容器与虚拟机一样，是隔离的（有一点要注意，我稍后会讨论到）。它们也拥有一个唯一ID和唯一的供人阅读的名字。容器对外公开服务是必要的，因此Docker允许公开容器的特定端口。
区别一：单进程与多进程之争非常精彩。你应该知道的是，Docker设计者极力推崇“一个容器一个进程的方式”，如果你要选择在一个容器中运行多个进程，那唯一情况是：出于调试目的，运行类似ssh的东西来访问运行中的容器，不过docker exec命令解决了这个问题。
区别二：容器是设计来运行一个应用的，而非一台机器。你可能会把容器当虚拟机用，但如我们所见，你将失去很多的灵活性，因为Docker提供了用于分离应用与数据的工具，使得你可以快捷地更新运行中的代码/系统，而不影响数据。

数据卷
数据卷让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。Docker允许你定义应用部分和数据部分，并提供工具让你可以将它们分开。使用Docker时必须做出的最大思维变化之一就是：容器应该是短暂和一次性的。
卷是针对容器的，你可以使用同一个镜像创建多个容器并定义不同的卷。卷保存在运行Docker的宿主文件系统上，你可以指定卷存放的目录，或让Docker保存在默认位置。保存在其他类型文件系统上的都不是一个卷，稍后再具体说。


链接是Docker的另一个重要部分。
容器启动时，将被分配一个随机的私有IP，其它容器可以使用这个IP地址与其进行通讯。这点非常重要，原因有二：一是它提供了容器间相互通信的渠道，二是容器将共享一个本地网络。

要开启容器间通讯，Docker允许你在创建一个新容器时引用其它现存容器，在你刚创建的容器里被引用的容器将获得一个（你指定的）别名。我们就说，这两个容器链接在了一起。
因此，如果DB容器已经在运行，我可以创建web服务器容器，并在创建时引用这个DB容器，给它一个别名，比如dbapp。在这个新建的web服务器容器里，我可以在任何时候使用主机名dbapp与DB容器进行通讯。
Docker更进一步，要求你声明容器在被链接时要开放哪些端口给其他容器，否则将没有端口可用。

在创建镜像时有一点要注意。Docker允许你在一个镜像中指定卷和端口。从这个镜像创建的容器继承了这些设置。但是，Docker不允许你在镜像上指定任何不可移植的内容。

你可以定义要公开的端口，但仅限那些在创建链接时公开给其他容器的端口，你不能指定公开给宿主的端口，因为你无从知晓使用那个镜像的宿主有哪些端口可用。
你也不能在镜像上定义链接。使用链接要求通过名字引用其他容器，但你无法预知每个使用那个镜像的宿主如何命名容器。
镜像必须完全可移植，Docker不允许例外。


Cgroups
这是Linux内核功能，它让两件事情变成可能：
[图片]限制Linux进程组的资源占用（内存、CPU）[图片]为进程组制作 PID、UTS、IPC、网络、用户及装载命名空间
这里的关键词是命名空间。比如说，一个PID命名空间允许它里面的进程使用隔离的PID，并与主PID命名空间独立开来，因此你可以在一个PID命名空间里拥有自己的PID为1的初始化进程。其他命名空间与此类似。然后你可以使用cgroup创建一个环境，进程可以在其中运行，并与操作系统的其他进程隔离开，但这里的关键点是这个环境上的进程使用的是已经加载和运行的内核，因此额外支出与运行其他进程几乎是一样的。Chroot之于cgroup就好像我之于绿巨人（The Hulk）、贝恩（Bane）和毒液（Venom）的组合（译者注：本文作者非常瘦弱，后三者都非常强壮）。


Union文件系统允许通过union装载来达到一个分层的积累变化。在union文件系统里，文件系统可以被装载在其他文件系统之上，其结果就是一个分层的积累变化。每个装载的文件系统表示前一个文件系统之后的变化集合，就像是一个diff。

也就是说，镜像只是一个json，它指定了从该镜像运行的容器的特性，union装载点保存在哪里，要公开什么端口等等。每个镜像与一个union文件系统相关联，每个Docker上的union文件系统都有一个上层，就像是计算机科技树（不像其他树有一大堆的家族）。

容器之所以是短暂的，是因为当你从镜像上创建一个容器，Docker会创建一个空白的union文件系统加载在与该镜像关联的union文件系统之上。
由于union文件系统是空白的，这意味着没有变化会被应用到镜像的文件系统上，当你创建一些变化时，文件就能体现出来，但是当容器停止，该容器的union文件系统会被丢弃，留下的是你启动时的原始镜像文件系统。除非你创建一个新的镜像，或制作一个卷，你所做的变化在容器停止时都会消失。卷所做的是在容器内指定一个目录，以便在union文件系统之外保存它。
卷基本上与镜像相同，不过现在还指定了一些公开给宿主的端口，也声明了卷位于宿主的位置，容器状态是从现在直到结束，

docker pull ubuntu:latest
docker images
docker run --rm -ti ubuntu /bin/bash
在运行run命令时，你可指定链接、卷、端口、窗口名称（如果你没提供，Docker将分配一个默认名称）等等。
我们在后台运行一个容器：
docker run -d ubuntu ping:8.8.8.8
输出的是分配的ID，因为是随机的，你的将有所不同。我们来检查一下容器是否开始运行了：docker ps

我们发现容器就是在那里面，它被自动分配了一个叫loving_mcclintock的名称。我们看看容器里正在发生什么：docker exec -ti loving_mcclintock /bin/bash

LXC为Linux Container的简写。Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。

而 LXC所实现的隔离性主要是来自内核的命名空间, 其中pid、net、ipc、mnt、uts 等命名空间将容器的进程、网络、消息、文件系统和hostname 隔离开。LXC所做的事情远不止隔离，它还包含模板管理、冻结以及其它更多的功能。

Linux的3.12内核支持6种Namespace：
UTS: hostname（本文介绍）IPC: 进程间通信 （之后的文章会讲到）PID: "chroot"进程树（之后的文章会讲到）NS: 挂载点，首次登陆Linux（之后的文章会讲到）NET: 网络访问，包括接口（之后的文章会讲到）USER: 将本地的虚拟user-id映射到真实的user-id（之后的文章会讲到）
如下是一个程序的完整骨架，用于从子进程启动/bin/bash程序（为了保持例子简单，所以去掉了错误检查）：

